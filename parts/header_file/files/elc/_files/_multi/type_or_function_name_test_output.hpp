//type_or_function_name_test_output.hpp
//at namespace ::
//multi when ELC_STRING & ELC_BASE_STREAM
/*
未完成的elc解释器base_stream文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/ELC-lang/ELC
*/
/*
			   ,??????????????????????????
			   ????????????????????????????
			  ?????????????????????????????+
			  ?????+++++++++++++++++++++++++
			 ?????+++++++++++++++++++++++++
			??????++++++++++++++++++++++++
			?????++
		   ?????+++
		  ??????+++IIIIIIIIIIIIIIIIII
		  ?????+++++IIIIIIIIIIIIIIIIII
		 ?????++++++++++++++++++++++++
		??????+++++++++++++++++++++++:
		?????++
	   ?????+++
	  ??????++
	  ??????????????????????????????II
	 ??????????????????????????????IIII
	,?????????????????????????????IIIII+
	 =???++++++++++++++++++++++++++III?
	   ?++++++++++++++++++++++++++++I+
*/
#if !defined(ELC_multi_type_or_function_name_test_output)//pls skip define check as this part is muti
#define ELC_multi_type_or_function_name_test_output
namespace elc::defs{
	#include "../_share/_defs.hpp"

	namespace stream_n{
		//typename output only for text_ostream_t<char_t>
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const type_name_t&name)noexcept(noexcept_text_ostream<stream_T>){
			return stream << to_char_t_str(name);
		}
		//output type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const base_type_info_t&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << info.get_name();
		}
		//output ::std::type_info
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const ::std::type_info&info)noexcept(noexcept_text_ostream<stream_T>){
			return stream << type_name_t{info.name()};
		}

		//function name output only for text_ostream_t<char_t>
		template<text_ostream stream_T>
		decltype(auto)operator<<(stream_T&&stream,const function_name_t&name)noexcept(noexcept_text_ostream<stream_T>){
			return stream << to_char_t_str(name);
		}
	}

	#include "../_share/_undefs.hpp"
}
#endif

//file_end

