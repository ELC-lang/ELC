//base
//at namespace ::
/*
未完成的elc解释器include文件
由steve02081504与Alex0125设计、编写
转载时请在不对此文件做任何修改的同时注明出处
项目地址：https://github.com/steve02081504/ELC
*/
#if !defined(ELC_BASE)
	#define ELC_BASE
	#include <cstdint>//u64int、64int
	#include <cstddef>//nullptr_t
	#include <cstdlib>//exit、size_t
	#include <cstring>//memcpy、memmove
	#include <new>//operator new(T*)
	#include <algorithm>//max、min
	namespace std{//cpp20还未实现，占位。
//*
		template<size_t N,class T>
		[[nodiscard]]constexpr T*assume_aligned(T*ptr){return ptr;}
//*
		#if defined(_MSC_VER)
		[[nodiscard]]inline void*aligned_alloc([[maybe_unused]]std::size_t alignment,std::size_t size){return malloc(size);}
		#endif

		#if defined(__GNUC__)
		template<class,class,class=void>struct is_nothrow_convertible:std::false_type{};
		template<class From,class To>struct is_nothrow_convertible<From,To,enable_if_t<is_convertible_v<From,To>>>
		:bool_constant<noexcept(static_cast<To>(declval<From>()))>{};

		/*
		template<class From,class To>
		struct is_nothrow_convertible{
			static constexpr bool value=is_convertible_v<From,To>&&noexcept(To(declval<From>()));
		};
		*/

		template<class From,class To>
		inline constexpr bool is_nothrow_convertible_v=is_nothrow_convertible<From,To>::value;

		
		template<class T>
		struct remove_cvref{
			typedef remove_cv_t<remove_reference_t<T>>type;
		};
		template<class T>
		using remove_cvref_t=typename remove_cvref<T>::type;
		#endif

	}
	#include"_files\base\_body.hpp"
#endif

